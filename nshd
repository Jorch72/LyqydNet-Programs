local connections = {}

local function exLua (string)
	local nForcePrint = 0
	local func, e = loadstring( string, "lua" )
	local func2, e2 = loadstring( "return "..string, "lua" )
	if not func then
		if func2 then
			func = func2
			e = nil
			nForcePrint = 1
		end
	else
		if func2 then
			func = func2
		end
	end

	local tEnv = {}
	setmetatable( tEnv, { __index = getfenv() } )
	
	if func then
        setfenv( func, tEnv )
        local tResults = { pcall( function() return func() end ) }
        if tResults[1] then
        	local n = 1
        	while (tResults[n + 1] ~= nil) or (n <= nForcePrint) do
        		print( tostring( tResults[n + 1] ) )
        		n = n + 1
        	end
        else
        	print( tResults[2] )
        end
    else
    	print( e )
    end
end

local function exShell (string)
	local tWords = {}
	for match in string.gmatch(string, "[^ \t]+") do
		table.insert( tWords, match )
	end

	local sCommand = tWords[1]
	if sCommand then
		if shell.resolveProgram(sCommand) == "rom/programs/cd" then
			if #tWords < 2 then
				print( "Usage: cd <path>" )
			else
				local localDir = shell.dir()
				shell.setDir (connections[conn].netDir)
				local sNewDir = shell.resolve( tWords[2] )
				if fs.isDir( sNewDir ) then
					connections[conn].netDir = sNewDir
				else
					print( "Not a directory" )
				end
				shell.setDir (localDir)
			end
		elseif shell.resolveProgram(sCommand) == "rom/programs/edit" then
			localFile = shell.resolve(tWords[2])
			netfile.send(conn, localFile)
			netfile.receive(conn, localFile)
		else
			local localDir = shell.dir()
			shell.setDir (connections[conn].netDir)
			shell.run( sCommand, unpack( tWords, 2 ) )
			shell.setDir (localDir)
		end
	end
end

nshdExit = false

--initialization
while not nshdExit do
	conn, packetType, message = connection.listen(23)
	if conn == 0 then
		--daemon command logic
	else
		if connections[conn] and connections[conn].status == "open" then
			if packetType == "data" then
				--if not daemonMode then print("Remote Command: "..message) end
				print("Remote Command: "..message)
				term.redirect(connection.text(conn))
				if message == "lua" and not connections[conn].mode then
					connections[conn].mode = "lua"
					connections[conn].holdDir = connections[conn].netDir
					connections[conn].netDir = "lua"
				elseif connections[conn].mode and connections[conn].mode == "lua" then
					if message == "exit()" then
						connections[conn].mode = nil
						connections[conn].netDir = connections[conn].holdDir
					else
						exLua(message)
					end
				else
					if message == "reboot" or message == "exit" or message == "shutdown" then
						for cNum, cInfo in pairs(connections) do
							connection.send(cNum, "close", "end")
						end
						term.restore()
					end
					exShell(message)
				end
				term.restore()
				if connections[conn].netDir == "" then connections[conn].netDir = "/" end
				connection.send(conn, "done", connections[conn].netDir)
			elseif packetType == "query" then
				--reset connection
				connections[conn].status = "open"
				connections[conn].mode = nil
				connections[conn].netDir = "/"
				connection.send(conn, "response", "/")
				if not daemonMode then print("Client reconnected: "..connection.name(conn)) end
			elseif packetType == "close" then
				table.remove(connections, conn)
				if not daemonMode then print("Client disconnected: "..connection.name(conn)) end
				--close connection
			else
				--error
			end
		elseif packetType ~= "query" then
			connection.close(conn)
			--client thinks connection is open, but server thinks it isn't.
		else
			--open new connection
			local connInfo = {}
			connInfo.status = "open"
			connInfo.mode = nil
			connInfo.netDir = "/"
			table.insert(connections, conn, connInfo)
			connection.send(conn, "response", "/")
			if not daemonMode then print("Client connected: "..connection.name(conn)) end
		end
	end
end